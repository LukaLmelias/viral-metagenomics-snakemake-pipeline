
import os
 
#  """
#     Perform quality control on raw sequencing reads using fastp.

#     Input:
#         r1 (file): Path to the input forward raw read file.
#         r2 (file): Path to the input reverse raw read file.

#     Output:
#         fastp_R1 (file): Path to the output quality-controlled forward read file.
#         fastp_R2 (file): Path to the output quality-controlled reverse read file.
#         html (file): Path to the HTML report generated by fastp.
#         json (file): Path to the JSON report generated by fastp.

#     Params:
#         min_len (int): Minimum length of reads to retain.
#         window_size (int): Window size for quality control.
#         mean_qual (int): Mean quality threshold for trimming.
#         trim_tail (int): Trim tail quality threshold.
#         title (str): Title for the HTML report.
#     """    

rule fastp:   
    input:
        r1 = os.path.join(f"{raw_reads_path}", f"{{sample}}_{forward_extension}"),          
        r2 = os.path.join(f"{raw_reads_path}",f"{{sample}}_{reverse_extension}"),    
        
    output:
        fastp_R1 = os.path.join(f'{fastp_dir}', 'qc_reads', f'{{sample}}_R1.qc.fastq.gz'),
        fastp_R2 = os.path.join(f'{fastp_dir}', 'qc_reads', f'{{sample}}_R2.qc.fastq.gz'),
        html = os.path.join(f'{fastp_dir}', 'htmls', f'{{sample}}.html'),        
        json = os.path.join(f'{fastp_dir}', 'jsons', f'{{sample}}-fastp.json'),
         

    params:
        min_len = config['fastp_params']['min_len'],
        window_size = config['fastp_params']['window_size'],
        mean_qual = config['fastp_params']['mean_qual'],
        trim_tail = config['fastp_params']['trim_tail'],
        title = 'Fastp report {sample}'   # how to make it work it f string

    log: os.path.join(f'{fastp_dir}', "logs",f"{{sample}}.log")

    benchmark:os.path.join(f'{fastp_dir}','benchmark',f'{{sample}}.tsv')

    conda: config["conda"]["fastp_conda"] 

    threads: config['fastp_params']['threads'] 

    resources:
        mincpus=config['fastp_params']['threads'],
        runtime= lambda wildcards, attempt: attempt * config['fastp_params']['time'],        
        mem_mb= lambda wildcards, attempt: attempt * config["fastp_params"]["mem_mb"],
        
       
    shell:
        """
        time fastp --in1 {input.r1} --in2 {input.r2} \
        --out1 {output.fastp_R1} --out2 {output.fastp_R2} \
        -l {params.min_len} --detect_adapter_for_pe \
        --average_qual {params.mean_qual} \
        --cut_tail --cut_tail_window_size {params.window_size} \
        --cut_tail_mean_quality {params.mean_qual} \
        --cut_right --cut_right_window_size {params.window_size} \
        --cut_right_mean_quality {params.mean_qual} \
        --trim_tail1 {params.trim_tail} --trim_tail2 {params.trim_tail} \
        --thread {threads} -j {output.json} \
        --html {output.html} --report_title {params.title} &>> {log} 
        """

#  """
#     Generate a MultiQC report summarizing fastp QC reports across samples.

#     Output:
#         fastp_qc (directory): Directory containing MultiQC data for fastp QC reports.

#     Params:
#         input_dir (directory): Directory containing fastp JSON reports.
#         out_folder (directory): Output directory for MultiQC reports.
#     """      
rule fastp_multiqc:    
    output:
        fastp_qc = directory(os.path.join(f'{fastp_dir}', 'multiqc_reports','multiqc_data'))
    
    conda: config['conda']['multiqc_conda']
    
    params:
        input_dir = os.path.join(f'{fastp_dir}', 'jsons'),
        out_folder = os.path.join(f'{fastp_dir}','multiqc_reports')
    message:
        "Summary of fastp report across samples."
    shell:
        "multiqc {params.input_dir}  -o {params.out_folder} "

    #&>> {log}
